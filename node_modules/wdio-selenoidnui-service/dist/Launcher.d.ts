export interface ServiceOptions {
    pathToBrowsersConfig?: string;
    terminateWdioOnError?: boolean;
    selenoidVersion?: string;
    skipAutoPullImage?: boolean;
    selenoidContainerName?: string;
    selenoidUiContainerName?: string;
    selenoidUiVersion?: string;
    port?: number;
    selenoidPort?: number;
    dockerArgs?: string[];
    selenoidUiArgs?: string[];
    selenoidArgs?: string[];
    skipAutoPullImages?: boolean;
}
export interface BrowserConfig {
    [browser: string]: {
        default: string;
        versions: {
            [version: string]: {
                image: string;
                port: number;
                path: string;
            };
        };
    };
}
export default class SelenoidStandaloneService {
    private options;
    private log;
    private dockerSocketPath;
    private selenoidBrowsersConfigPath;
    private sessionTimeout;
    constructor(serviceOptions: ServiceOptions);
    stopSelenoid(): Promise<string>;
    stopSelenoidUi(): Promise<string>;
    stopSelenoidAndUi(): Promise<any>;
    startSelenoid(): Promise<string>;
    verifySelenoidBrowserConfig(): Promise<void>;
    pullRequiredBrowserFiles(): Promise<void>;
    pullRequiredSelenoidVersion(): Promise<void>;
    startSelenoidUi(): Promise<string>;
    imageType(imageName: string): void;
    doesImageExist(imageName: string): Promise<boolean>;
    pullRequiredSelenoidUiVersion(): Promise<void>;
    sleep(timeout: number): Promise<void>;
    waitForSelenoidToBeRunning(): Promise<void>;
    waitForSelenoidToBeStopped(): Promise<void>;
    onPrepare(_config: unknown, _capabilities: unknown): Promise<string>;
    onComplete(_exitCode: number, _config: unknown, _capabilities: unknown): Promise<string>;
}
